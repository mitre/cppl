.\" Emacs, use -*- mode: nroff -*-
.TH "cpplc" 1 "" "@PACKAGE_STRING@"
.SH NAME
cpplc \- a CPPL compiler
.SH SYNOPSIS
cpplc
.RB [ -o
.IR outfile ]
.RB [ -c | -d | -a | -i | -t | -s | -v ]
.RI [ infile ]
.SH DESCRIPTION
.LP
The
.B cpplc
program translates protocols specified in the Cryptographic Protocol
Programming Language and Datalog clauses into OCaml source.
Executable versions of each role in a protocol can be generated by
compiling each source, and a main routine written in OCaml, and
invoking the program with command-line options that are appropriate
for the role.  The object files must be linked with following OCaml
libraries: unix.cma, nums.cma, cryptokit.cma, and cppl.cma, and also
the C cryptokit library.
.SH OPTIONS
.TP
.B \-c
Generate code from CPPL input (default)
.TP
.B \-n
Generate signature (mli file) from CPPL input
.TP
.B \-d
Generate code from CPPL input that also produces protocol debugging output
.TP
.B \-a
Generate code from Datalog input to be inserted into an initial theory
.TP
.B \-i
Indent CPPL input
.TP
.B \-t
Indent CPPL input in which all inferred types have been made explicit
.TP
.B \-s
Generate Scheme S-Expressions from CPPL input mirroring its abstract syntax
.TP
.B \-v
Print version information and exit
.SH USAGE
To use the output of the compiler, each role requires a main routine
written in OCaml.  The main routine is responsible for populating the
routine's initial theory, installing Datalog clauses that are written
in OCaml, and then calling the CPPL procedure that implements the
role.  In what follows, assume the name of the file generated from the
protocol is protocol.ml.
.LP
Axioms in the initial theory that can be expressed in Datalog syntax
can be compiled into OCaml source using the \-a option.  If the name
of the OCaml file produced is axioms.ml, the main routine for a role
can load the axioms with:
.LP
.nf
	let theory = Protocol._t in
	List.iter (Cppl.assume theory) Axioms.axioms;
.fi
.LP
Some applications require predicates implemented by OCaml functions.
The predicates are called Datalog primitives.  If Primitive.prim is an
OCaml function that defines a primitive that takes as input three
arguments, the main routine registers it under the name \(lqprim\(rq
with:
.LP
	Cppl.add_primitive "prim" 3 Primitive.prim;
.LP
A primitive is a function that when given the number of expected
output values and a list of input values, returns either None to
signal failure, or a list of values of the specified length.
The type of a value is specified in the Cppl module.
.LP
.nf
	type value =
	  | Pub of pubkey
	  | Sym of symkey
	  | Nonce of nonce
	  | Text of text
	  | Name of name
.fi
.LP
Here is an example of a primitive that expects three text arguments,
and concatenates them to produce one output value.
.LP
.nf
	open Cppl
	let prim n l =
	  match n, l with
	  | 1, [Text a; Text b; Text c] ->
	      Some [Text (a ^ b ^ c)]
	  | _ -> None
.fi
.LP
Functions that implement a simple key store are available in the Cppl
module. Keys read from a key entry can be inserted into the initial
theory with code such as:
.LP
.nf
	try
	  while true do
	    let p, k = load_key_store_entry input in
	    let pubkey =
	      mkliteral "owns_key"
	        [mkval (Text p); mkval (Pub k)] in
	    assume theory (mkclause pubkey [])
	  done
	with End_of_file -> close_in input
.fi
.LP
The key can be retrieved with a guarantee of the form:
.LP
	owns_key(p:text, k:verkey)
.SH MISCELLANEOUS
Markus Mottl's OCamlMakefile can ease the process of generating the
various roles in a protocol specified in CPPL.
Place the protocol in a file that starts with:
.LP
	(*pp cpplc -d *)
.LP
and give the file a name with a \(lq.ml\(rq extension.  In a Makefile
that uses OCamlMakefile, treat it as an ordinary OCaml source file.
The OCamlMakefile will take care of invoking
.B cpplc.
.LP
For Datalog axioms, start the file with:
.LP
	(*pp cpplc -a *)
.SH CPPL SYNTAX
.LP
A CPPL program is a sequence of procedures.
The syntax of a procedure is:
.LP
.nf
PROCEDURE ::=
	ID (DECLS) (DECLS)
	assumes OPT_RELY
	proves OPT_GUAR
	STATEMENT end
.fi
.LP
where DECLS is zero or more declarations separated by commas, and the
assume and prove phrases are optional.
.LP
DECL ::= ID | ID : TYPE
.LP
The ID : TYPE phrase asserts an ID must contain values of the given
type.  The types are: name, text, nonce, channel, msg, pubkey, and
symkey.
.LP
.nf
STATEMENT ::=
	return
	|  let DECL = EXPR in STATEMENT
	|  send SEND
	|  send cases SEND_BRANCHES end
	|  receive ID RECEIVE
	|  receive ID cases RECEIVE_BRANCHES end
	|  match ID RECEIVE
	|  match ID cases RECEIVE_BRANCHES end
	|  call CALL
	|  call cases CALL_BRANCHES end
.fi
.LP
where SEND_BRANCHES is zero or more SENDs separated by vertical bars,
RECEIVE_BRANCHES is zero or more RECEIVEs separated by vertical bars,
and CALL_BRANCHES is zero or more CALLs separated by vertical bars.  A
match statement is similar to a receive statement except the
identifier names a message instead of a channel.
.LP
.nf
EXPR ::= ID
	|  new KEY_TYPE
	|  new nonce
	|  connect (ID)
	|  accept
	|  receive (ID)
.LP
SEND	::= OPT_GUAR --> ID MESSAGE STATEMENT
.LP
RECEIVE ::= MESSAGE --> OPT_RELY STATEMENT
.LP
CALL	::= OPT_GUAR --> _ STATEMENT
	|  OPT_GUAR --> PATH ID (DECLS) (DECLS) OPT_RELY STATEMENT
.LP
PATH	::= | PATH VARIABLE .
.LP
MESSAGE ::=
	DECL
	|  MESSAGE , MESSAGE
	|  TAG , MESSAGE
	|  { MESSAGE } DECL
	|  {| MESSAGE |} DECL
	|  [ MESSAGE ] DECL
	|  [| MESSAGE |] DECL
	|  <ID = MESSAGE>
	|  hash (MESSAGE)
	|  ( MESSAGE )
.LP
When the comma operator is used to concatenate and tag messages, it is
right associative.
.LP
OPT_GUAR ::= _ | QUERIES
.LP
OPT_RELY ::= _ | FORMULAS
.LP
QUERIES ::= QUERY | QUERIES and QUERY
.LP
FORMULAS ::= FORMULA | FORMULAS and FORMULA
.fi
.LP
With Datalog, a trust management formula uses Prolog-like syntax,
however, there are no function symbols, and every variable that occurs
in the head of a clause must also occur in its body.
.LP
QUERY ::= LITERAL
.LP
FORMULA ::= LITERAL BODY
.LP
where BODY is either empty or starts with :- and is followed by one or
more literals separated by commas.
.LP
.nf
LITERAL ::=
	ID
	|  ID ( TERMS )
	|  TERM = TERM
.fi
.LP
TERM ::= DECL | VARIABLE
.LP
where TERMS is one or more TERMs separated by commas.
.LP
An identifier ID is a lowercase Latin letter followed by zero or more
Latin letters, digits, or underscore.  A tag is an uppercase Latin
letter or a digit followed by zero or more Latin letters, digits, or
underscore.  A VARIABLE is an uppercase Latin letter followed by zero
or more Latin letters, digits, or underscore, and is treated as a
logical variable.  A predicate symbol is in the same syntactic
category as is an identifier.
.LP
A one-line comment starts with %, and a multi-line comment starts
with (* and ends with *).
